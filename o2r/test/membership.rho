new insertArbitrary(`rho:registry:insertArbitrary`), stdout(`rho:io:stdout`), debug(`rho:io:stderr`) in {
  new membership, store, return in {
    // Insert the name into the registry
    // Wrap in bundle+ so only write is possible for those who lookup
    insertArbitrary!(bundle+{*membership}, *return) |

    // Receive the URI generated by the registry
    for (@xUri <- return) {
      // Something like: `rho:id:rtu77e1cj1ky7dpqyoc6o8rcdseseax35qi7w37hbf3astmrcupusi`
      stdout!(["registerd membershp contract at:", xUri])
    }
    |
    store!({})
    |
    contract @(*membership, "add")(@cert, return) = {
      // debug!("membership(...")|
      match cert {
        {@"claim"!(
          {claim /\ {@"binding"!(
            @"discord"!(@"id"!(discordId) | _rest1)
              |@"publicKey"!(publicKey)) | _rest2}}) |
          @"endorsement"!(endorsement)} => {
          debug!(["ready to check:", discordId, claim, endorsement])
          |
          new checkResult in {
            @"ed25519Verify"!(claim.toByteArray(), endorsement.hexToBytes(),
              // springboard PK
              "1ad20b9fe34e2ab5715940ae2048d907ce7908921ca1dfd9763f0eb03dcb3f73".hexToBytes(),
              *checkResult) |
            for (@sigOk <- checkResult) {
              debug!(["sigOK?", sigOk]) |
              if(sigOk) {
                for (@old <- store) {
                  store!(old.set(discordId, cert)) |
                  // what to return? How about the key to the store...
                  return!(discordId)
                }
              } else {
                return!(Nil)
              }
            }
          }
        }
      }
    }
    |
    contract @(*membership, "lookup")(@id, return) = {
      // debug!(["lookup", id]) |
      for(@db <- store) {
        // debug!(["found:", db.get(id)])|
        store!(db) |  // wishing for peek...
        return!(db.get(id))
      }
    }
    |
    // Testing...

    new added, found in {
      @(*membership, "add")!(
        {
          @"claim"!(@"binding"!(@"discord"!(@"guild"!("257555930173014017") |
            @"id"!("358096357862408195") |
            @"role"!("412648251196702741") |
            @"userName"!("dckc#3040")) |
            @"publicKey"!("ebede01df79043137cf8a42a4989c755ce503bdf8064bfa161a9cb48f401784f")) |
            @"memberSigTime"!("2018-10-21T03:20") |
            @"memberSignature"!("f51bc1a6cb68e121c16ccf00240367b669bc24fbf22da69e5669157bf3dee24550c67200e18cc7d136825c5910fb825ff7b32b0a5739e949857ff482d5199508")) |
          @"endorsement"!("6339a85f250e339a8471c1324975dfd0b05eb5047431d9e47a2ecfb7783c4ddf85285ebf9e5b162d3b0aa48c379896d3a36cec736d05c47ea2af14f79ba04702")
        }, *added)
      |
      for (@what <- added) {
        debug!(["added", what]) |
        @(*membership, "lookup")!("358096357862408195", *found) |
        for (@it <- found) {
          stdout!(["lookup got:", it])
        }
      }
    }
  }
  |

  new x in {
    @"ed25519Verify"!(
      {
        @"binding"!(@"discord"!(@"guild"!("257555930173014017") |
          @"id"!("358096357862408195") |
          @"role"!("412648251196702741") |
          @"userName"!("dckc#3040")) |
          @"publicKey"!("ebede01df79043137cf8a42a4989c755ce503bdf8064bfa161a9cb48f401784f")) |
        @"memberSigTime"!("2018-10-21T03:20") |
        @"memberSignature"!("f51bc1a6cb68e121c16ccf00240367b669bc24fbf22da69e5669157bf3dee24550c67200e18cc7d136825c5910fb825ff7b32b0a5739e949857ff482d5199508")
      }.toByteArray(),
      "6339a85f250e339a8471c1324975dfd0b05eb5047431d9e47a2ecfb7783c4ddf85285ebf9e5b162d3b0aa48c379896d3a36cec736d05c47ea2af14f79ba04702".hexToBytes(),
      "1ad20b9fe34e2ab5715940ae2048d907ce7908921ca1dfd9763f0eb03dcb3f73".hexToBytes(),
      *x) |
    for(@ok <- x) {
      debug!(["sig result:", ok])
    }
  }
}
